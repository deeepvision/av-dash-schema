directive @specifiedBy(url: String!) on SCALAR
type Aggregate {
    count: Int!
}

type Attachment implements Node {
    filename: String!
    filesize: String!
    id: ID!
    recording: Recording!
    url: URL!
}

type AuthenticatedUser {
    sessionToken: String!
    user: User!
}

type AuthenticatedUserPayload {
    authenticatedUser: AuthenticatedUser
    errors: [InputValidationError!]!
}

type Bible implements Node {
    book(id: ID!): BibleBook!
    books: [BibleBook!]!
    id: ID!
    isDramatized: Boolean!
    title: String!
}

type BibleBook implements Node {
    chapter(id: ID!): BibleChapter!
    chapterCount: Int!
    chapters: [BibleChapter!]!
    id: ID!
    isDramatized: Boolean!
    title: String!
}

type BibleChapter implements Node {
    id: ID!
    text: String!
    title: String!
    url: URL!
}

type BibleVerse implements Node {
    id: ID!
    text: String!
    url: URL!
}

type BibleConnection {
    aggregate: Aggregate
    edges: [BibleEdge!]
    nodes: [Bible!]
    pageInfo: PageInfo!
}

type BibleEdge {
    cursor: String!
    node: Bible!
}

type BlogPost implements Node {
    body: String!
    id: ID!
    image: Image
    title: String!
}

type BlogPostConnection {
    aggregate: Aggregate
    edges: [BlogPostEdge!]
    nodes: [BlogPost!]
    pageInfo: PageInfo!
}

type BlogPostEdge {
    cursor: String!
    node: BlogPost!
}

type Collection implements Node {
    contentType: CollectionContentType!
    id: ID!
    location: String
    logoImage: Image
    logoImageWithFallback: Image!
    recordings(
        after: String
        first: Int
        orderBy: [RecordingsOrder!]
        presenterId: ID
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    sequence(
        after: String
        first: Int
        orderBy: [SequenceOrder!]
        search: String
        sponsorId: ID
    ): SequenceConnection!
    sponsor: Sponsor
    title: String!
}

type CollectionConnection {
    aggregate: Aggregate
    edges: [CollectionEdge!]
    nodes: [Collection!]
    pageInfo: PageInfo!
}

enum CollectionContentType {
    AUDIOBOOK_SERIES
    CONFERENCE
    STORY_PROGRAM
}

type CollectionEdge {
    cursor: String!
    node: Collection!
}

input CollectionsOrder {
    direction: OrderByDirection!
    field: CollectionsSortableField!
}

enum CollectionsSortableField {
    CREATED_AT
    ID
    TITLE
}

scalar Date

type Image {
    url(size: Int!): URL!
}

type InputValidationError {
    message: String!
}

enum Language {
    CHINESE
    ENGLISH
    FRENCH
    GERMAN
    JAPANESE
    RUSSIAN
    SPANISH
}

type MediaFile implements Node {
    bitrate: Int!
    duration: Float!
    filename: String!
    filesize: String!
    id: ID!
    recording: Recording!
    url: URL!
}

type Mutation {
    favoriteRecording(id: ID!): Boolean!
    login(input: UserLoginInput!): AuthenticatedUserPayload!
    loginSocial(input: UserLoginSocialInput!): AuthenticatedUserPayload!
    playlistAdd(input: UserPlaylistAddInput!): UserPlaylist!
    playlistDelete(playlistId: ID!): Boolean!
    playlistRecordingAdd(playlistId: ID!, recordingId: ID!): Boolean!
    playlistRecordingRemove(playlistId: ID!, recordingId: ID!): Boolean!
    playlistUpdate(
        input: UserPlaylistUpdateInput!
        playlistId: ID!
    ): UserPlaylist!
    signup(input: UserSignupInput!): AuthenticatedUserPayload!
    unfavoriteRecording(id: ID!): Boolean!
    updateMyProfile(input: UserUpdateProfileInput!): AuthenticatedUserPayload!
}

interface Node {
    id: ID!
}

enum OrderByDirection {
    ASC
    DESC
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type Person implements Node {
    description: String!
    givenName: String! #?
    surname: String! #?
    firstName: String!
    lastName: String!
    salutation: Salutation
    suffix: String
    designations: String
    id: ID!
    name: String!
    photo: Image
    photoWithFallback: Image!
    recordings(
        after: String
        collectionId: ID
        first: Int
        orderBy: [RecordingsOrder!]
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    summaryBio: String!
    extendedBio: String!
    website: String
    phone: String
    email: String
    contactPerson: String
    contactEmail: String
    isPreapproved: Boolean
    requiredEvaluations: Int
    isHidden: Boolean
    statistic: PersonRolesStatistic
}

type PersonRolesStatistic {
    speaker: PersonRoleStatistic
    author: PersonRoleStatistic
    nurrator: PersonRoleStatistic
    translator: PersonRoleStatistic
}
type PersonRoleStatistic {
    sermonsCount: Int
    storiesCount: Int
    audioBookTracksCount: Int
    musicTracksCount: Int
}

enum Salutation {
    MR
    MS
    DR
}

type PersonConnection {
    aggregate: Aggregate
    edges: [PersonEdge!]
    nodes: [Person!]
    pageInfo: PageInfo!
}

type PersonEdge {
    cursor: String!
    node: Person!
}

input PersonsOrder {
    direction: OrderByDirection!
    field: PersonsSortableField!
}

enum PersonsSortableField {
    CREATED_AT
    ID
    NAME
}

type PopularRecording {
    recording: Recording!
    weight: Float!
}

type PopularRecordingConnection {
    aggregate: Aggregate
    edges: [PopularRecordingEdge!]
    nodes: [PopularRecording!]
    pageInfo: PageInfo!
}

type PopularRecordingEdge {
    cursor: String!
    node: PopularRecording!
}

type Query {
    audiobible(id: ID!): Bible
    audiobibles(after: String, first: Int): BibleConnection!
    audiobook(id: ID!): Sequence
    audiobooks(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [SequenceOrder!]
        search: String
        sponsorId: ID
    ): SequenceConnection!
    audiobookSeries(id: ID!): Collection
    audiobookSerieses(
        after: String
        first: Int
        language: Language!
        orderBy: [CollectionsOrder!]
        search: String
        sponsorId: ID
    ): CollectionConnection!
    audiobookTrack(id: ID!): Recording
    audiobookTracks(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [RecordingsOrder!]
        presenterId: ID
        search: String
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    blogPost(id: ID!): BlogPost
    collection(id: ID!): Collection
    collections(
        after: String
        first: Int
        language: Language!
        orderBy: [CollectionsOrder!]
        search: String
        sponsorId: ID
    ): CollectionConnection!
    conference(id: ID!): Collection
    conferences(
        after: String
        first: Int
        language: Language!
        orderBy: [CollectionsOrder!]
        search: String
        sponsorId: ID
    ): CollectionConnection!
    featuredBlogPosts(
        after: String
        first: Int
        language: Language!
    ): BlogPostConnection!
    featuredRecordings(
        after: String
        collectionId: ID
        contentType: RecordingContentType = SERMON
        first: Int
        language: Language!
        presenterId: ID
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    me: AuthenticatedUser
    musicAlbum(id: ID!): Sequence
    musicAlbums(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [SequenceOrder!]
        search: String
        sponsorId: ID
    ): SequenceConnection!
    musicBookTags(after: String, first: Int, language: Language!): TagConnection!
    musicMoodTags(after: String, first: Int, language: Language!): TagConnection!
    musicTrack(id: ID!): Recording
    musicTracks(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [RecordingsOrder!]
        presenterId: ID
        search: String
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    person(id: ID!): Person
    popularRecordings(
        after: String
        collectionId: ID
        contentType: RecordingContentType = SERMON
        first: Int
        language: Language!
        presenterId: ID
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): PopularRecordingConnection!
    presenters(
        after: String
        first: Int
        language: Language!
        orderBy: [PersonsOrder!]
        search: String
    ): PersonConnection!
    recording(id: ID!): Recording
    recordings(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [RecordingsOrder!]
        presenterId: ID
        search: String
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    sequence(id: ID!): Sequence
    sequences(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [SequenceOrder!]
        search: String
        sponsorId: ID
    ): SequenceConnection!
    series(id: ID!): Sequence
    serieses(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [SequenceOrder!]
        search: String
        sponsorId: ID
    ): SequenceConnection!
    sermon(id: ID!): Recording
    sermons(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [RecordingsOrder!]
        presenterId: ID
        search: String
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    sponsor(id: ID!): Sponsor
    sponsors(
        after: String
        first: Int
        language: Language!
        orderBy: [SponsorsOrder!]
        search: String
        withMusic: Boolean
    ): SponsorConnection!
    stories(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [RecordingsOrder!]
        presenterId: ID
        search: String
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    story(id: ID!): Recording
    storyProgram(id: ID!): Collection
    storyPrograms(
        after: String
        first: Int
        language: Language!
        orderBy: [CollectionsOrder!]
        search: String
        sponsorId: ID
    ): CollectionConnection!
    storySeason(id: ID!): Sequence
    storySeasons(
        after: String
        collectionId: ID
        first: Int
        language: Language!
        orderBy: [SequenceOrder!]
        search: String
        sponsorId: ID
    ): SequenceConnection!
}

type Recording implements Node {
    attachments: [Attachment!]!
    collection: Collection
    contentType: RecordingContentType!
    copyrightYear: Int
    description: String
    downloadDisabled: Boolean!
    duration: Float!
    id: ID!
    mediaFiles: [MediaFile!]!
    presenters: [Person!]!
    publishAt: Date
    recordingDate: Date
    sequence: Sequence
    shareUrl: URL
    speakers: [Person]!
    translators: [Person]!
    conference: Conference
    series: [Series]!
    tags: [Tag]
    bibleReferences: [BibleReference]
    isFeatured: Boolean
    stage: RecordingStage
    hiddenAt: Date
    discributionAgreement: DiscributionAgreement
    publishDestinations: [PublishDesctination]
    legalReviewers: [User]
    technicalReviewers: [User]
    contentReviewers: [User]
    messages: [Message]
    language: Language
    publishedAt: Date
    reviewStatus: ReviewInfo
    arhivedAt: Date
    issues: [Issue]
    sponsor: Sponsor
    title: String!
    transcript: Transcript
    videoFiles: [VideoFile!]!
    viewerHasFavorited: Boolean!
}

type BibleReference {
    book: BibleBook
    chapter: BibleChapter
    verse: BibleVerse
}

type Conference implements Node {
    id: ID!
    title: String!
    series: [Series]
}

type Series implements Node {
    id: ID!
    title: String!
}

type Issue implements Node {
    id: ID!
    type: IssueType
    startTime: String
    endTime: String
    description: String
    isGeneral: Boolean
}

type IssueType {
    id: ID!
    title: String,
    category: IssueCategory
}

type IssueCategory {
    title: String
    issues: [IssueType]
}

type ReviewInfo {
    content: ReviewStatus
    technical: ReviewStatus
    legal: ReviewStatus
}

enum ReviewStatus {
    PENDING
    FLAGGED
    ACCEPTED
    REJECTED
}

type Message implements Node {
    id: ID!
    type: MessageType
    actionType: ActionType #exists if type === ACTION
    user: User
    replies: [Message]
    forward: Message
    assignments: [User]
    createdAt: Date
}

enum ActionType {
    CHANGE
    ARCHIVE
}

enum MessageType {
    ACTION
    COMMENT
}

type DiscributionAgreement implements Node {
    id: ID!
    title: String
}

type PublishDesctination implements Node {
    id: ID!
    title: String
    url: String
}

enum RecordingStage {
    DRAFT
    SCREENING
    SCHEDULE
    PUBLISHED
}

type RecordingConnection {
    aggregate: Aggregate
    edges: [RecordingEdge!]
    nodes: [Recording!]
    pageInfo: PageInfo!
}

enum RecordingContentType {
    AUDIOBOOK_TRACK
    MUSIC_TRACK
    SERMON
    STORY
}

type RecordingEdge {
    cursor: String!
    node: Recording!
}

input RecordingsOrder {
    direction: OrderByDirection!
    field: RecordingsSortableField!
}

enum RecordingsSortableField {
    CREATED_AT
    ID
    TITLE
}

type Sequence implements Node {
    collection: Collection
    contentType: SequenceContentType!
    description: String!
    id: ID!
    logoImage: Image
    logoImageWithFallback: Image!
    recordings(
        after: String
        collectionId: ID
        first: Int
        orderBy: [RecordingsOrder!]
        presenterId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    sponsor: Sponsor
    summary: String!
    title: String!
}

type SequenceConnection {
    aggregate: Aggregate
    edges: [SequenceEdge!]
    nodes: [Sequence!]
    pageInfo: PageInfo!
}

enum SequenceContentType {
    AUDIOBOOK
    MUSIC_ALBUM
    SERIES
    STORY_SEASON
}

type SequenceEdge {
    cursor: String!
    node: Sequence!
}

input SequenceOrder {
    direction: OrderByDirection!
    field: SequenceSortableField!
}

enum SequenceSortableField {
    CREATED_AT
    ID
    TITLE
}

type Sponsor implements Node {
    collections(
        after: String
        contentType: CollectionContentType = CONFERENCE
        first: Int
        orderBy: [CollectionsOrder!]
        search: String
    ): CollectionConnection!
    description: String!
    id: ID!
    location: String
    logoImage: Image
    logoImageWithFallback: Image!
    recordings(
        after: String
        collectionId: ID
        contentType: RecordingContentType = SERMON
        first: Int
        orderBy: [RecordingsOrder!]
        presenterId: ID
        sequenceId: ID
        tagName: String
    ): RecordingConnection!
    sequences(
        after: String
        collectionId: ID
        contentType: SequenceContentType = SERIES
        first: Int
        orderBy: [SequenceOrder!]
        search: String
    ): SequenceConnection!
    title: String!
    website: String
}

type SponsorConnection {
    aggregate: Aggregate
    edges: [SponsorEdge!]
    nodes: [Sponsor!]
    pageInfo: PageInfo!
}

type SponsorEdge {
    cursor: String!
    node: Sponsor!
}

input SponsorsOrder {
    direction: OrderByDirection!
    field: SponsorsSortableField!
}

enum SponsorsSortableField {
    CREATED_AT
    ID
    TITLE
}

type Tag implements Node {
    id: ID!
    name: String!
}

type TagConnection {
    aggregate: Aggregate
    edges: [TagEdge!]
    nodes: [Tag!]
    pageInfo: PageInfo!
}

type TagEdge {
    cursor: String!
    node: Tag!
}

type Transcript implements Node {
    id: ID!
    text: String!
    keywords: String
    transcriber: Transcriber
}

type Transcriber implements Node {
    id: ID!
    title: String!
}

scalar URL

type User implements Node {
    createdAt: Date!
    favoriteRecordings(
        after: String
        collectionId: ID
        first: Int
        orderBy: [RecordingsOrder!]
        presenterId: ID
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    givenName: String!
    id: ID!
    name: String!
    playlist(id: ID!): UserPlaylist
    playlists(
        after: String
        first: Int
        language: Language!
        orderBy: [UserPlaylistsOrder!]
    ): UserPlaylistConnection!
    surname: String!
    email: String!
    state: String
    city: String
    address: String
    postalCode: String
    settings: UserSettings
}

type UserSettings {
    wiretapQuality: WiretapQuality
    autoplay: Boolean
    #    timeZone:
}

type WiretapQuality {
    value: Int,
}

input UserLoginInput {
    email: String!
    password: String!
}

input UserLoginSocialInput {
    givenName: String
    socialId: String!
    socialName: UserSocialServiceName!
    socialToken: String!
    surname: String
}

type UserPlaylist implements Node {
    id: ID!
    isPublic: Boolean!
    language: Language!
    recordings(
        after: String
        collectionId: ID
        first: Int
        presenterId: ID
        sequenceId: ID
        sponsorId: ID
        tagName: String
    ): RecordingConnection!
    summary: String!
    title: String!
}

input UserPlaylistAddInput {
    isPublic: Boolean!
    language: Language!
    summary: String
    title: String!
}

type UserPlaylistConnection {
    aggregate: Aggregate
    edges: [UserPlaylistEdge!]
    nodes: [UserPlaylist!]
    pageInfo: PageInfo!
}

type UserPlaylistEdge {
    cursor: String!
    node: UserPlaylist!
}

input UserPlaylistsOrder {
    direction: OrderByDirection!
    field: UserPlaylistsSortableField!
}

enum UserPlaylistsSortableField {
    CREATED_AT
    ID
    TITLE
}

input UserPlaylistUpdateInput {
    isPublic: Boolean!
    summary: String
    title: String!
}

input UserSignupInput {
    email: String!
    password: String!
}

enum UserSocialServiceName {
    APPLE
    FACEBOOK
    GOOGLE
}

input UserUpdateProfileInput {
    email: String!
    givenName: String!
    password: String
    surname: String!
}

type VideoFile implements Node {
    bitrate: Int!
    container: String!
    duration: Float!
    filename: String!
    filesize: String!
    height: Int!
    id: ID!
    logUrl: URL
    recording: Recording!
    url: URL!
    width: Int!
}

